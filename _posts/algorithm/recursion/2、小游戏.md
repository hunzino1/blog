# 小游戏
- 前言
    
    **程序运行会出现越界的情况，原因是数组的定义不对，外包了一圈，所以下标要从（1，1）开始，特此备注。**
    
- 参考

    [程序设计实习：12.2小游戏](http://dy.163.com/v2/article/detail/D8EUJKBH0512RHOV.html)

- 描述


        连连看游戏。
    
   ![](https://hunzino1.github.io/assets/images/2019/algorithm/recursion/%E5%B0%8F%E6%B8%B8%E6%88%8F/1.png)
    
- 要求


        是否存在一条满足题意的路径能连接给定的两个游戏卡片。
    
   ![](https://hunzino1.github.io/assets/images/2019/algorithm/recursion/%E5%B0%8F%E6%B8%B8%E6%88%8F/2.png)
    
- 输入：

    矩形板数组
    
    第一行包括两个整数 w和h (1 <= w, h <= 75), 分别表示矩形板的宽度和长度
    
            
             原文很啰嗦，没必要知道：
        
             输入包括多组数据: 一个矩形板对应一组数据
    
    　　      第一行包括两个整数 w和h (1 <= w, h <= 75), 分别表示矩形板的宽度和长度
    
    　　      下面的h行, 每行包括w个字符, 表示矩形板上的游戏卡 片分布情况:
    
    　　      使用 ‘X’ 表示这个地方有一个游戏卡片 使用 空格 表示这个地方没有游戏卡片 5 输入 (2/2)
    
    　　      之后每行上包括4个整数: x1, y1, x2, y2 (1 <= x1, x2 <= w, 1 <= y1, y2 <= h)
    
    　　      给出两个卡片在矩形板上的位置 注意: 矩形板左上角的坐标是(1,1) 输入保证这两个游戏卡片所处的位置是不相同的 如果一行上有4个0, 表示这组测试数据的结束
    
              如果一行上给出w = h = 0, 那么表示所有的输入结束了 6 输出
    
    　　       对每一个矩形板, 输出一行 “Board #n:”, n是输入数据的 编号
    
    　　       对每一组需要测试的游戏卡片输出一行. 这一行的开头 是 “Pair m: ”, 这里m是测试卡片的编号（对每个矩形板, 编号都从1开始）
    
    　　       如果可以相连, 找到连接这两个卡片的所有路径中包括 线段数最少的路径, 输出 “k segments.” k是找到的最优路径中包括的线段的数目
    
    　　       如果不能相连, 输出 “impossible.”
    
    　　       每组数据之后输出一个空行
    
    
   ![](https://hunzino1.github.io/assets/images/2019/algorithm/recursion/%E5%B0%8F%E6%B8%B8%E6%88%8F/3.png)

- 问题分析


        1、自相似性表现在每走一步的探测方式相同,所以可以考虑使用递归方法。
        
        2、自起点需要遍历四个方向，去满足条件的最小值。 所以 枚举 + 递归
        
        3、如果一直保持同一个方向，那么step要一直保持。 本案例是使用方向改变计算长度的， 所以需要一个方向标识。
        
        4、连连看是允许临时离开板子的，所以在外围要加一圈。
        
- 问题解决：（终止条件和递归函数）
    
       
        1、终止条件：
        
            到达终点 或者 重复已经走过的点  （前提条件： 当前位置在板子有效范围内）
            
            （x,y）  -->  （x > -1 && x < w + 2 && y > -1 && y > h + 2） &&
                            ((x == end_x && y == end_y) || (board[x][y] == 1))
        
        2、递归函数
            
             首先考虑需要的参数：
                1、当前坐标 （x,y）
                2、重点坐标  (end_x, end_y)
                
             此外，方向改变步长加一，所以要有当前方向记录。
             四个方向要做比较，所以要记录当前已经走的步数。
                3、f
                4、step
                
                
- 算法实现


            /**
                 *
                 * @param now_x   当前位置
                 * @param now_y
                 * @param end_x   目标位置
                 * @param end_y
                 * @param step    已走步数
                 * @param f       方向
                 */
                public static void search(int now_x, int now_y, int end_x, int end_y, int step, int f) {
                    if (step > minstep) {
                        return;
                    }
            
                    if (now_x == end_x && now_y == end_y) {
                        if (step < minstep) {
                            minstep = step;
                        }
                        return;
                    }
            
                    for (int i = 0; i < 4; i++) {
                        int x = now_x + to[i][0];
                        int y = now_y + to[i][1];
            
                        /**
                         * 1 不越界
                         * 2、没有格挡且没有走过 或者 当前点是终点
                         *   因为此处是当前坐标的下一个坐标，所以需要判断是否是终点的情况
                         */
                        if((x > -1 && x < width + 2 && y > -1 && y < height + 2) &&
                                ((board[x][y] == 0 && mark[x][y] == 0) || (board[x][y] == 1 && x == end_x && y == end_y))
                                ) {
                            mark[x][y] = 1;
                            if (f == i) {
                                search(x, y, end_x, end_y, step, i);
                            } else {
                                search(x, y, end_x, end_y, step + 1, i);
                            }
                            //回溯，重置为未标记
                            mark[x][y] = 0;
                        }
                    }
                } 
            
- 小结


        递归的条件
        
        　　自相似性表现在每走一步的探测方式相同, 可以用递归算法求解 定义并记录路径方向 判断下一步的位置是否符合要求 搜索过程Search( )
        
        　　朝一个方向走下去, 如果走不通, 则换个方向走; 四个方向都走不通, 则 回到上一步的地方, 换个方向走; 依次走下去, 直到走到终点 计算路径数目
        
        　　需要记录每一步走的方向, 如果上一步走的方向和这一步走的方向相同, 递归搜索时路径数不变, 否则路径数加1