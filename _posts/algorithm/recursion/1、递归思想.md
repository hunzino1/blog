# 递归

- 什么是递归？

- 基本思想

      1、 待求问题的解  --->   输入变量x的函数f(x)    也就是说将问题的解用一个函数f(x)去表示
      
      2、 解决方法：   查找函数g(),   g()需要满足  f(x)  =   g(f(x - 1));    也就是说f(x)的规模在下降的一个 g（）
      
      3、 由已知的 f(0) 和 g()， 最终求出 f(x)
      
      推广：
      
      输入的变量可能是多个 x、y、z.....  x - 1 的变化也可以推广到 x - n,
      
      总之 递归的过程 是冲着 "出口"的方向。 （问题规模不断缩小的方向）
      
      我的总结：
        
        找到f(x) 和 f(0),  g() 是关键
      
- 枚举 与 递归
    
    共同点：  都是列举子问题求解。
    
    不同点：
    
        枚举：
        
            子问题直接是平行的，相互独立的。 每个子问题都是问题的一种可能的形式；
            
        递归：
        
            子问题和原问题之间是纵向的， 之间会有依赖关系，层层迭代。
            
- 递归的两种形式：

        1、 自身调用自身     fun（） 调用 fun()
    
        2、 间接调用    fun（） 调用  a(), a() 调用 fun()
    

- 递归三要点：(其实第三点不重要，前两点是关键)

     1、递归式 g():   如何将问题划分为子问题
    
     2、递归出口
    
        递归的终止条件。
        
     3、界函数：
     
        使得问题规模越来越小的函数。
        
      int factorial（int n） {
     
        if (n == 0) {
            return 0;
        }
        
        return n * factorial(n - 1);
      end
      
      1、递归式  n * f（n - 1）
      
      2、出口  n == 0
      
      3、界函数  n - 1
            
- 栈的溢出

    ![](https://hunzino1.github.io/assets/images/2019/algorithm/recursion/1.png)
    
     如图，求取4!的时候，会将 4 * 3！ 一直到 1 * 0！ 一直放在栈中，首先明确了递归的原理。
    
     就是将子问题依次入栈，直到递归出口，再依次出栈。
    
     问题：
    
     因为这些局部变量（4、3、2、1）都是存在栈上，如果局部变量体积较大或者递归层次太深，就可能造成栈的溢出。
    
     解决方案：
    
        可以考虑使用全局数组 或者 动态分配数组。
