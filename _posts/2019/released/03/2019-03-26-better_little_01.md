---
layout:     post
title:      每日一件001 - 常见知识点汇总
category: better
tags: [better]
excerpt: 一个人有多努力，就会有多幸运。
---

每日一件001 - 常见知识点汇总
============================

面试求职，不止要求的是本职工作，而且还需要有比较扎实的基础知识。

虽然在实践中加深理解最好，但是实际工作中相当一部分知识点基本都遇不到，所以汇总总结一下。

温故知新。

题目和答案是问答形式，相当于一个完成的面试流程。

------------------------------------------------------

1.Q: 多线程下同步的方法？
-----------------------------

#### 1.操作系统--线程同步

线程同步：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作。

#### 2. 临界区：

每个进程中访问临界资源的那段代码称为临界区（临界资源是一次仅允许一个进程使用的共享资源）。

#### 3. 线程同步的几种方式：

信号量，互斥量，事件(信号,各个线程对中断事件的响应)

```html
一、互斥量：(锁)

互斥量有两种状态--解锁和加锁。当一个线程（或进程）需要访问临界区时，它调用互斥锁。如果该互斥量当前是解锁的（即临界区可用），此调用成功，调用线程可以自由进入该临界区。另一方面，如果该互斥量已经加锁，调用线程被阻塞，直到在临界区中的线程完成并调用互斥锁。如果多个线程被阻塞在该互斥量上，将随机选择一个线程并允许它获得锁。

二、信号量：(OnlyChild)

它允许同一时刻多个线程访问同一资源，但是需要一个计数器来控制可以使用某共享资源的线程数目。

三、事件（信号）：(notify/notifyAll)

通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。
```

2.Q: 线程通信方式？
-----------------------

> 线程通信本身这个问题就是错误的，线程本就是cpu随机切换的，一个进程包含多个线程，同一进程中的线程因属同一地址空间，可直接通信。
>
> 总结1就是线程通信的方式。

#### 进程通信方式？

> 1-4 很好理解，其中1、3、4和线程大同小异，消息队列可以专门作为一个知识点了解。

1. 信号量(semophore ) ： 

      信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

2. 消息队列( messagequeue ) ：

      消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

3. 信号 (sinal ) ： 

      信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

4. 共享内存(shared memory ) ：

      共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。

5. 管道( pipe )：

      管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。

6. 有名管道 (namedpipe) ： 

      有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。

7. 套接字(socket ) ： 

      套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。

3.消息队列( message queue )
------------------------------------------


4.见过一些线程拥有自己的资源么？
----------------------------------------

> 问的是线程的公有资源和私有资源。

线程是进程内部运行的执行流.**linux下没有真正的线程**.一般使用进程来模拟线程.Linux下的进程叫做轻量级进程.

线程是CPU调度的基本单位.

#### 1.线程共享

> 线程共享的数据一般都是 **进程维度的代码和数据**

```html
线程共享的环境包括：(进程维度的代码和数据)
      进程代码段、
      进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)、
      进程打开的文件描述符、
      信号的处理器、
      进程的当前目录和
      进程用户ID与进程组ID。
```

#### 2.线程私有（很好理解，都是为了找到线程本身或者保证不被其他线程干扰）

> linux是有线程创建和终止函数的pthread_create 和 pthread_exit。
>
> 进程拥有这许多共性的同时，还拥有自己的个性。有了这些个性，线程才能实现并发性。这些个性包括：

```html
1.线程ID (唯一确定线程)

每个线程都有自己的线程ID，这个ID在本进程中是唯一的。进程用此来标识线程。

2.寄存器组的值 （切回时恢复线程自身）

由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线程切换到另一个线程上时，
必须将原有的线程的寄存器集合的状态保存，以便将来该线程在被重新切换到时能得以恢复。

3.线程的堆栈(函数堆栈，每个线程对应一组函数调用顺序，互不影响)

堆栈是保证线程独立运行所必须的。
线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程必须拥有自己的函数堆栈，使得函数调用可以正常执行，不受其他线程的影响。

4.错误返回码（每个线程产生的错误不能被覆盖）

由于同一个进程中有很多个线程在同时运行，可能某个线程进行系统调用后设置了error值，
而在该线程还没有处理这个错误，另外一个线程就在此时被调度器投入运行，这样错误值就有可能被修改。
所以，不同的线程应该拥有自己的错误返回码变量。

5.线程的信号屏蔽码（线程只对的处理逻辑有针对性）

由于每个线程所感兴趣的信号不同，所以线程的信号屏蔽码应该由线程自己管理。但所有的线程都共享同样的信号处理器。

6.线程的优先级

由于线程需要像进程那样能够被调度，那么就必须要有可供调度使用的参数，这个参数就是线程的优先级。

```

#### 3. 举例说明

> IPC (进程间通信)

fork()函数： fork()允许创建多个进程，但是进程间存在通信问题。 因为每个进程都有自己的独立的内存空间。

5.那怎么实现线程安全呢？
----------------------------------

> java的三种方式

#### 1. 同步代码块 synchronized(this) {}

```java
synchronized (this) {
    System.out.println(this.getClass().getName().toString());
    if (tickets <= 0) {
        return;
    }
    System.out.println(Thread.currentThread().getName()+"--->售出第：  "+tickets+" 票");
    tickets--;
    try {
        Thread.sleep(100);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
```

#### 2. 同步方法   synchronized void synMethod() {}

> 直接调用同步方法。

```java
synchronized void synMethod() {
    synchronized (this) {
        if (tickets <=0) {
            return;
        }
        System.out.println(Thread.currentThread().getName()+"---->售出第 "+tickets+" 票 ");
        tickets-- ;
    }
}
```

#### 3. Lock锁机制 

> Lock锁机制， 通过创建Lock对象，采用lock()加锁，unlock()解锁，来保护指定的代码块

```java
Lock lock = new ReentrantLock();

@Override
public void run() {
    // Lock锁机制
    while(tickets > 0) {
        try {
            lock.lock();
            if (tickets <= 0) {
                return;
            }
            System.out.println(Thread.currentThread().getName()+"--->售出第：  "+tickets+" 票");
            tickets--;
        } catch (Exception e1) {
            // TODO Auto-generated catch block
            e1.printStackTrace();
        }finally {
            lock.unlock();
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    if (tickets <= 0) {
        System.out.println(Thread.currentThread().getName()+"--->售票结束！");
    }
}
```

6.Q：那你说下ThreadLocal吧。
--------------------------------

通过类ThreadLocal实现每一个线程都有自己的共享变量，解决的就是每个线程绑定自己的值。

【就是这么一个变量a，各个线程都能访问它，而且每个线程获取a时都是该线程上次自己所赋的值或者是初始值】

一句话：每个线程都能访问a，而a对于每个线程都是该线程特有的值。

```java
public class Tools {
   public static ThreadLocal tl = new ThreadLocal();
}

public class Run {
    public static void main(String[] args) {
        try {
            ThreadA a = new ThreadA();
            ThreadB b = new ThreadB();
            a.start();
            b.start();
            for (int i = 0; i < 100; i++) {
                if (Tools.tl.get() == null) {
                    Tools.tl.set("Main" + (i + 1));
                } else {
                    System.out.println("Main get Value=" + Tools.tl.get());
                }
                Thread.sleep(200);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

#### ThreadLocal的实现原理

每个Thread的对象都有一个ThreadLocalMap，当创建一个ThreadLocal的时候，就会将该ThreadLocal对象添加到该Map中，其中键就是ThreadLocal，值可以是任意类型。

threadlocal是线程独有的，在Thread类下有一个map作为成员，key为当前线程thread，value则是多个threadLocald的变量。当要使用时，以当前线程作为key，获取对应的变量。

get 和 set 方法：

![thread_loacl](https://hunzino1.github.io/assets/images/2019/better/2019_03/thread_local.jpeg)


7.Q: 那线程池怎么办呢？一个线程一直存在？
-------------------------------------------------

> 这个问题是承接上面的问题，一个线程池中假如使用了threadLocal, 因为线程池会复用线程，被复用的线程去执行新的任务时会使用被上一个线程操作过的 value 对象， 从而产生不符合预期的结果。

线程池中的线程在任务执行完成后会被复用，所以在线程执行完成时，要对 ThreadLocal 进行清理（清除掉与本线程相关联的 value 对象）。不然，被复用的线程去执行新的任务时会使用被上一个线程操作过的 value 对象，从而产生不符合预期的结果。

在每个线程执行完成时，应该清理 ThreadLocal。 从这个角度来说，ThreadLocal是为了那些使用完就销毁的线程设计的。

ThreadLocal的remove方法，finally

8.Q：为什么要用线程池，为什么不自己写一个？[线程池专题]()
----------------------------------------------

#### 为什么要用线程池

1.减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。

2.可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。

#### 为什么不手写一个

缓冲队列

A：（你为什么要问我这么感觉有坑的问题）线程池提供了各种参数，我们可以根据业务场景来设置对应的参数。比如，当更多的线程被资源限制时，可以使用线程池的队列在存储任务，自己单纯写线程启动的话，可能这些状况下会有问题。

8.Q: 为什么要用spring。
----------------------------

> 个人感觉就是优点列举

1. 解耦和分层架构： 降低了组件之间的耦合性 ，实现了软件各层之间的解耦
2. AOP: 容器提供了AOP技术，利用它很容易实现如权限拦截，运行期监控等功能
3. 声明式事务的支持
4. 方便集成各种优秀框架

总之，效率提高了。

9.Q：spring基础的知道么，IOC,AOP之类的？
----------------------------------------

#### IOC(DI)
控制反转模式（也称作依赖性介入）的基本概念是：不创建对象，但是描述创建它们的方式。在代码中不直接与对象和服务连接，但在配置文件中描述哪一个组件需要哪一项服务。容器 （在 Spring 框架中是 IOC 容器） 负责将这些联系在一起。

依赖注入（Dependecy Injection）和控制反转（Inversion of Control）是同一个概念，具体的讲：当某个角色需要另外一个角色协助的时候，在传统的程序设计过程中，通常由调用者来创建被调用者的实例。但在spring中创建被调用者的工作不再由调用者来完成，因此称为控制反转。创建被调用者的工作由spring来完成，然后注入调用者, 因此也称为依赖注入。

spring以动态灵活的方式来管理对象 ， 注入的两种方式，设置注入和构造注入。

- 设置注入的优点：直观，自然
- 构造注入的优点：可以在构造器中决定依赖关系的顺序。

#### AOP
Aop则是面向切点的编程。可以定义一个切点，在它的前后做一些共同的操作。比如打个日志什么的。
联想rails，before_action等等；

10.Q: 为啥不直接打？
----------------------

1. 实现代码复用，提高使用效率。
2. 解耦：实现低耦合高内聚；

A： （喵喵喵？）可能有一些操作是通用的，AOP通过定义切点，可以是我们不需要反复写相同的代码。比如打印个方法开始时间，结束时间之类的。

```
放弃spring cloud,可以补充一下概念


```

11.Q: 你说你们有微服务是吧？那服务GG了怎么办？
---------------------------------------------

A： 您是想问熔断那方面么？这个我目前的工作只涉及了服务发现和网关配置。熔断那部分我理解是在整个服务GG时，给出一个处理。我还没有碰到过这种情况，基本每个服务都有多个实例。服务发现和注册会通过健康检查检查各个实例的心跳。只要有一个实例存活，服务注册和服务发现会给出相应的策略，还没有接触到熔断那一块的知识。

12.Q: 那你说一下spring cloud都有哪些模块？
---------------------------------------------

A： 服务发现，网关gateway，熔断，配置中心等。

13.Q: 那你说一些ZK,EUREKA之类的区别之类的？
--------------------------------------------
A:  （这里已经有点丧了）都是分布式的框架。分布式需要面临CAP的问题。

#### zookeeper

#### eureka


14.Q： 说下CAP。
---------------------

A:  一致性。。。(一致性、可用性、分区容错性)

Q: 说下HashMap的实现。
A：（我爱基础，然并卵）一个object的数组，采用链地址法，被分进同一个桶内的元素会形成链表。Jdk8后，链表长度超过一个常量（记得好像是8）是，会变成一棵树。

Q: 扩容会发生什么？
A：首先扩容数组会变成原来的两倍。

Q: 为什么是两倍？
A: 数组大小采用位运算，一定是2的x次幂。然后分为两部分，原来的低位部分和新增的高位部分。逐个看各个桶的哈希值，在新通仍处于低位的桶可以直接移动，高位则需要再次put。

Q: 扩容会出现什么性能问题？
A:高位的元素还是需要重新put，这个过程中有性能消耗。hashMap有一个影响因子，可以通过调整这个值，来调整resize的频率。（这个题我有点没get到面试官想问什么。 和学长讨论了一下：OOM）

Q：知道sql注入么？
A：知道。一般会根据业务场景拼接sql语句。有些该填写参数的地方，填写了sql语句，使得最终生成sql语句执行了预期以外的语义。

Q: 为什么orm框架可以防止sql注入？
A：mybatis中使用#{arg}，将被包含在‘‘字符串内，从而保证该部分即使包含sql关键字，也不会作为sql执行。

Q: 问点数据库相关的吧。Mysql哪些存储引擎？
A： InnoDb， myisam， memory。InnoDB是mysql目前的默认存储引擎，聚簇索引，有行级锁。Myisam不支持行级锁，查找较快，然而增改致命。

Q： 如何高性能使用mysql
A: (购买和阅读高性能mysql) 在表设计合理的情况下，建立合适的索引。

Q: innoDB索引底层什么样？
A：B+树和类哈希索引的集合。B+树同时有父子节点和前后续节点，查找起来更快。

Q: 那节点的值是什么？
A： （—喵喵—）。不知道，猜测应该包含主键值。
（高性能Mysql。P166， 包含主键值、事务ID、用于事务和MVCC的回归指针以及剩余列）

Q：那如何简历多列索引？
A: 符合左侧优先原则。
Q： 那假设有性别和课程号，谁在前谁在后？
A： 性别吧，性别只有两个值，在前能好的筛选？（不确定了已经。需要再查一些资料）


手写代码：

1.1-n个数，找出按照字典序排序的第K个数。

思路1：最坏直接当成字符串处理，排序，取K
思路2：重写compare方法，快排，找到K，
思路3：（玩脱）找到小于等于n的下一个字典序数。

写头两个思路妥妥的，嘴贱说了三个，不作不死。事件原因没写完。

2.一个超大的文件，每一行都是Timestamp：content，时间有序，找指定时间范围的content。
1、让我写个MR。
2、行号中序

