---
layout:     post
title:      技术栈3 - Design Pattern(1) - 设计模式简介
category: stack
tags: [stack]
excerpt: 
---

设计模式简介
=============

该文档简单介绍了设计模式，包括设计模式6大原则，设计模式分类以及设计模式简介.

阅读完该文档后，您将会了解到:

* 设计模式简介
* 设计模式6大原则.
* 设计模式分类

这篇博客主要是借鉴菜鸟教程，错误之处还望指正。

--------------------------------------------------------------------------------

一 设计模式
----------

### 定义

设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。

**模式：在某些场景下，针对某类问题的某种通用的解决方案。**

场景：项目所在的环境

问题：约束条件，项目目标等

解决方案：通用、可复用的设计，解决约束达到目标。

### 设计模式的三个分类

**创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程。**

**结构型模式：把类或对象结合在一起形成一个更大的结构。**

**行为型模式：类和对象如何交互，及划分责任和算法。**

![](https://hunzino1.github.io/assets/images/2019/design_pattern/kind_of_pattern.png)

| 序号 | 模式 & 描述 | 包括 |
| ---------- | ----------- | ---------- |
|  1         | **创建型模式**<br> 创建型模式目的都是创建实例，但没有直接使用new方法。|-工厂模式（Factory Pattern）<br> -抽象工厂模式（Abstract Factory Pattern）<br> - 单例模式（Singleton Pattern）<br> 建造者模式（Builder Pattern）<br> 原型模式（Prototype Pattern） |
| ---------- | ----------- | ---------- |
|  2         | **结构型模式**<br>这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。|- 适配器模式（Adapter Pattern）<br> - 桥接模式（Bridge Pattern）<br> - 过滤器模式（Filter、Criteria Pattern）<br> - 组合模式（Composite Pattern）<br> - 装饰器模式（Decorator Pattern）<br> - 外观模式（Facade Pattern）<br> - 享元模式（Flyweight Pattern）<br> - 代理模式（Proxy Pattern） |
| ---------- | ----------- | ---------- |
|  3         |**行为型模式** <br>这些设计模式特别关注对象之间的通信。|- 责任链模式（Chain of Responsibility Pattern）<br> - 命令模式（Command Pattern）<br> - 解释器模式（Interpreter Pattern）<br> - 迭代器模式（Iterator Pattern）<br> - 中介者模式（Mediator Pattern）<br> - 备忘录模式（Memento Pattern）<br> - 观察者模式（Observer Pattern）<br> - 状态模式（State Pattern）<br> - 空对象模式（Null Object Pattern）<br> - 策略模式（Strategy Pattern）<br> - 模板模式（Template Pattern）<br> - 访问者模式（Visitor Pattern）<br>            |
| ---------- | ----------- | ---------- |


二 六大原则
----------

### 1 开闭原则（Open Close Principle）

> 对模块可以通过继承去扩展功能，但是对类定义实现修改关闭（private）。

开闭原则的意思是：对扩展开放，对修改关闭。

在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。

### 2 里氏代换原则（Liskov Substitution Principle）

> 任何使用基类的地方，都可以用子类去代替基类。

里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

### 3 依赖倒转原则（Dependence Inversion Principle）

> 对接口进行实现，而不是具体类定义。

这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。

### 4 接口隔离原则（Interface Segregation Principle）

> 利用接口定义，降低耦合。

这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。

### 5 迪米特法则，又称最少知道原则（Demeter Principle）

> 还是接口。

最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。

### 6 合成复用原则（Composite Reuse Principle）

> 多使用组合，少使用继承。

合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。

三 23种设计模式简介
---------------------

### 1 创建型
- 单例模式：某个类只能有一个实例，提供一个全局的访问点。
- 简单工厂：一个工厂类根据传入的参量决定创建出那一种产品类的实例。
- 工厂方法：定义一个创建对象的接口，让子类决定实例化那个类。
- 抽象工厂：创建相关或依赖对象的家族，而无需明确指定具体类。
- 建造者模式：封装一个复杂对象的构建过程，并可以按步骤构造。
- 原型模式：通过复制现有的实例来创建新的实例。


### 2 结构型
- 适配器模式：将一个类的方法接口转换成客户希望的另外一个接口。
- 组合模式：将对象组合成树形结构以表示“”部分-整体“”的层次结构。
- 装饰模式：动态的给对象添加新的功能。
- 代理模式：为其他对象提供一个代理以便控制这个对象的访问。
- 亨元（蝇量）模式：通过共享技术来有效的支持大量细粒度的对象。
- 外观模式：对外提供一个统一的方法，来访问子系统中的一群接口。
- 桥接模式：将抽象部分和它的实现部分分离，使它们都可以独立的变化。


### 3 行为型
- 模板模式：定义一个算法结构，而将一些步骤延迟到子类实现。
- 解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器。
- 策略模式：定义一系列算法，把他们封装起来，并且使它们可以相互替换。
- 状态模式：允许一个对象在其对象内部状态改变时改变它的行为。
- 观察者模式：对象间的一对多的依赖关系。
- 备忘录模式：在不破坏封装的前提下，保持对象的内部状态。
- 中介者模式：用一个中介对象来封装一系列的对象交互。
- 命令模式：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。
- 访问者模式：在不改变数据结构的前提下，增加作用于一组对象元素的新功能。
- 责任链模式：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。
- 迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。
