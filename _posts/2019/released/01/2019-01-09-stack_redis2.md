---
layout:     post
title:      技术栈1 - Redis(1)
no-post-nav: true
category: stack
tags: [stack]
excerpt: 
---

> 《redis实战》第四章是关于redis数据安全和性能保障的，主要涉及持久化、复制、事务等知识点；
> 第二章是redis应用的几个实例，第三章是redis操作命令，没有记录笔记的价值。

#### 第四章收获总结
====================================

#### 4.1 持久化

```html
p62: 持久化的概念：
  将内存数据写入硬盘，保证服务器重启数据也不丢失。

  1、两种持久化方式：
    快照持久化(snapshoting)
    AOF持久化(append-only file)

  2、快照
    1、概念： 对应某一刻的数据创建副本到硬盘。
      也就是某一个时间点的数据库的一个拷贝。例如8:00:00执行快照操作，就是将8点这一刻的数据保存到硬盘上，而8:00之后的数据更新需要再次快照才能持久化。
      一句话，某一个时间点的redis数据保存在网盘叫做一次快照。

      问题：
      如上，如果8：00之后没有快照，那么8:00之后更新的数据，服务重启就会丢失；最新数据只会复原到最新的一次快照；
      此外，如果7点的时候快照一次，8点快照的时候出错了，服务挂了，8点这次快照是在进行中，会被清理掉，也就是最新的快照备份是7点那份；
      如果服务挂了的时候8点的快照刚好完成，那么最新的备份就是8点的，但是8点之后更新的数据因为没有快照就全部丢失了。

      p63: 创建快照的方式： bgsave 和 save 两个命令；
      具体可以参考《redis实战》
      bgsave 和 save的区别：
        bgsave命令是主线程创建一个子进程去执行快照，文件越大创建和快照的时间越长； 优点是几个G的小容量数据不会影响主进程的业务操作，
        而且只有当进程执行内存写入时主进程和子进程才不共享内存，其余时间共享内存；(fork:即想内存中写入数据除外，其余都共享内存)

        save 在完成快照之前，阻塞等待；

        选取：当容易有一定的数据损失时，可以使用快照；
          对于内存数据比较小的情况，可以使用bgsave命令； 而大数据10多GB甚至更大时，bgsave创建子进程会造成卡顿，如果容忍等待，可以使用save命令。

        快照执行：
          1、自动触发
            save 60 10000 60秒内有10000次写入就会触发快照操作
          2、手动发送save或bgsave

  3、AOF持久化
    1、概念： 将redis所有的写命令追加到一个AOF文件中。 恢复数据时就依次执行AOF文件中的命令就行了。

    对比快照，对于每一条写命令都进行追加操作，这样就可以避免数据损失。

    但是要兼顾数据安全和写入性能，如appendsync everysec选项，每秒一次写入。appendsync no则是由操作系统控制何时写入。

    缺点：AOF文件的大小； 解决方案： 重写/压缩

    p68: bgrewriteaof命令，重写除去AOF文件中重复的命令；  但是这与快照中的bgsave一样，都会创建一个子进程执行，但是文件大小更大，耗时更多。
    两个命令选项：ayto-aof-rewrite-percentage 和 ayto-aof-rewrite-min-size 
    例如ayto-aof-rewrite-percentage 100 ayto-aof-rewrite-min-size 64MB AOF文件大小超过64MB，而且比之前AOF文件大了一倍（100%）时执行bgrewriteaof命令。

  4、总结
    两种持久化方式适用场景不一样，持久化之后还要对持久化文件进行备份，防止文件丢失。

```

#### 4.2 复制
