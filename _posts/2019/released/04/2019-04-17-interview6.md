---
layout:     post
title:      面试总结6 - 头条商业化部门面试准备
category: interview
tags: [interview]
excerpt: 一个人有多努力，就会有多幸运。
---

面试总结6 - 头条商业化部门面试准备
=======================================

啥也不说，就是努力。

-------------------------------------

1 算法题目
---------------------

### 1 找出[1,n]范围内按照字典排序的最小第k个值

[找出(1,n)范围内按照字典排序的最小第k个值](https://hunzino1.github.io/interview/2019/03/26/toutiao_algorithm.html)

### 2 输入1234，输出1243 字典排序算法

[字典排序](https://hunzino1.github.io/better/2019/04/09/toutiao_questions.html)

### 3 1，1，2，3，5... 第n个数是什么

f(1) = 1
f(2) = 1
f(n) = f(n - 1) + f(n - 2)

### 5、字典排序

[字典排序](https://hunzino1.github.io/better/2019/04/09/toutiao_questions.html)

### 6 比较底层的原理， 不止会用，为啥要用他，他是怎么实现的

### 7 反转链表

三种思路：

1. 头插法
2. 栈，先入栈，再出栈
3. 递归思路，因为有栈

```ruby
# 假设头结点不为空
# 1 头插法
def reverse(node)
  return node if node.nil? || node.next.nil?

  head = node
  cur = node.next
  while cur do
    temp = head
    head.next = cur.next
    cur.next = head
    head = cur
    cur = temp.next
  end

  head
end

# 2 栈
def reverse(node)
  return node if node.nil? || node.next.nil?

  stack = []
  while node do
    stack << node
    node = node.next
  end

  head = satck.pop
  node = head
  while !stack.empty? do
    node.next = stack.pop
    node = node.next
  end

  head
end
```

递归实现讲解：
![reverse_list](https://hunzino1.github.io/assets/images/2019/interview/reverse_list.png)

如图，我之前疑惑的地方在于 reverse_list是进行了四重递归，而在四重递归中同时都交换了指针指向，真是我忽略的。

就是最后一层递归，不光是返回了4这个尾节点，还交换了4和3的指向。

图中红色是递归走向，变化的只有head，直到head=4时开始回溯，返回4，并且4->3，3->nil

再回溯 4->3 -> 2, 2 -> nil

```ruby

#首先剑指offer反转打印
def reverse_print(node)
  if !node.nil?
    if !node.next.nil?
      reverse_print(node.next)
    end
    puts node.value
  end
end

# 3 递归
# 递归反转打印和反转链表是不同的
def reverse(node)
  return node if node.nil? || node.next.nil?

  new_head = reverse(node.next) #一直循环到链尾 
  node.next.next = node # 翻转链表的指向
  node.next = null # 记得赋值NULL，防止链表错乱
  return new_head # 新链表头永远指向的是原链表的链尾
end
```

### 8 跳台阶问题（递归、迭代）

f(n) = f(n - 1) + f(n - 2)

代码省略，还有一种，青蛙可能调1，2，3...n-1阶。

思路：

f(n) = f(n-1) + f(n-2) + ... + f(1)
f(n-1) = f(n-2) + ... + f(1)

故 f(n) = 2 * f(n-1)

### 13 二叉树变双向链表

[二叉树变双向](https://hunzino1.github.io/interview/2019/03/29/interview_offer_hard_for_me.html)

思路： 分成三部分，根节点，左子树，右子树

因为有序所以中序遍历，当前节点node， node的左、右节点增加一个指向node的指针，（对应的分别是前一个节点，后一个节点）

递归思路解决。

中序遍历是有序的。

递归思路不太懂，整个非递归思路的：

```ruby
# 主要思路是遍历每个节点都是先将该节点自身以及最左节点依次入栈
# 然后每次出栈一个节点之后重复上述步骤
#
def convert(root)
  return nil if root.nil?
  # p 是遍历指针
  # pre 指向上一次遍历的节点
  p, pre = root, nil

  stack = []
  # 只有第一次有用，找双向链表的头结点，用root标识
  is_head = true

  while !p.nil? || !stack.empty? do
    # 当前节点，以及最左节点依次进栈
    while !p.nil? do
      stack.push p
      p = p.left
    end

    # 取最后一个左节点
    p = stack.pop
    if is_head
      root = p
      pre = p
      is_head = false
    else
      pre.last = p
      p.pre = pre
      pre = p
    end

    p = p.right
  end

  root
end
```

### 14 100万内的素数

编程珠玑的第一章，这道题主要是考察是优化能力。

#### 1 普通

```ruby
def is_sushu?(n)
  2.upto(n-1).each do |i|
    if n % i == 0
      return false
    end
  end

  return true
end

def sushu_list(n)
  res = [2, 3, 5]
  6.upto(n).each do |i|
    if is_sushu?(i)
      res << i
    end
  end

  res
end
```

#### 2 改进1

计算素数时，不必2~n求余，至Math.sqrt(n).to_i即可

问题：

性能监视工具发现时间不减反增，因为sqrt费时，故只求一次sqrt

```ruby
def is_sushu?(n, bound)
  # 在此处每一次求开方就很费时
  # bound = Math.sqrt(n).to_i
  2.upto(n-1).each do |i|
    if n % i == 0
      return false
    end
  end

  return true
end

def sushu_list(n)
  res = [2, 3, 5]

  # 只计算一次bound，然后传入上述函数
  bound = Math.sqrt(n).to_i
  6.upto(n).each do |i|
    if is_sushu?(i, bound)
      res << i
    end
  end

  res
end

```

#### 3 优化3

1、偶数肯定不是素数
2、 实现%2， %3， %5过滤， 不过要实现把2，3，5加进来

```ruby
def is_sushu?(n, bound)
  2.upto(bound).each do |i|
    if i >= n - 1
      return true
    end
    if n % i == 0
      return false
    end
  end

  return true
end

def sushu_list(n)
  res = [2, 3, 5]

  # 只计算一次bound，然后传入上述函数
  bound = Math.sqrt(n).to_i
  6.upto(n).each do |i|
    if i % 2 == 0 || i % 3 == 0 || i % 5 == 0
      next
    end

    if is_sushu?(i, bound)
      res << i
    end
  end

  res
end
```

### 15 复制复杂链表

思路：

1、 hash法

2、 奇数位偶数位法

2 mysql
---------------------

### 4 sql题目(待定)

### 1 sql的事务的四大特性

原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability)

1 原子性

> 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚

2 一致性

> 一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。

　　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。

3 隔离性

> 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。

    即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。

    关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到

4 持久性

持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

### 9 mysql的四个事务级别（隔离性：隔离级别）

未提交读（Read Uncommitted）、提交读（Read Committed）、可重复读（Repeated Read）、序列化（Serializable）

以两个事务A/B为例。
```html
1）未提交读（Read Uncommitted）：一个事务能够读取到 别的事务中没有提交的更新数据。
    B更新数据，但是还未提交，此时A就能读到B提交的数据。

    可能出现脏读，因为B可能回滚。
2）读提交（Read Committed）：一个事务只能读取到别的事务提交的更新数据。(oracle默认的)

只有B提交之后A才能读取提交数据，只能读取到已经提交的数据，解决了脏读，但未解决不可重复读。

一个事务A多次读取数据，假设在第一次读取数据的过程中，另一个事务B修改了数据，导致A两次读取的数据不一致。

3）可重复读（Repeated Read）：保证同一事务中先后执行的多次查询将返回同意结果，不受其他事务的影响。这种隔离级别可能出现幻读。（mysql默认的）

幻读： 事务A对数据进行了修改操作，同时事务B对数据进行了插入操作，事务A查询时会发现还有一条未修改的数据，就跟幻象一样。

4）序列化（Serializable）：

读写相互堵塞，行锁。

不允许事务并发执行，强制事务串行执行，就是在读取的每一行数据上都加上了锁，读写相互都会阻塞。这种隔离级别最高，是最安全的，性能最低，不会出现脏读，不可重复读，幻读，丢失更新。
```

那么怎么设置隔离级别呢

SET TRANSACTION ISOLATION LEVEL READ COMMITTED; //设置提交读隔离级别

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE; //设置序列化隔离级别

### 10 脏读 可重复读 幻读

首先事务的隔离级别是为了解决并发问题， 并发，注意前提。

那么先来了解下并发带来的问题：

1 丢失更新 Lost Update：(没有加锁)

两个事务A/B同时更新一行数据，最后一个事务B的更新会覆盖掉第一个事务A的更新，从而导致第一个事务更新的数据丢失，这是由于没有加锁造成的。

![lost_update](https://hunzino1.github.io/assets/images/2019/interview/lost_update.jpeg)

2 脏读Dirty Reads：（读未提交）

一个事务B看到了另外一个事物A没有提交的更新数据。这是事务没有隔离造成的。

![dirty_read](https://hunzino1.github.io/assets/images/2019/interview/dirty_read.jpeg)

3 不可重复读：Non-Repeatable Reads

在同一事务A中，多次读取同一数据但是返回不同的结果，也就是有其他事务B更改了这些数据。

明白了，读的不一致是正常的，这一主要关注的重点是在同一事务A中，同一事务中。

![no_repeat_read](https://hunzino1.github.io/assets/images/2019/interview/no_repeat_read.jpeg)

4 幻读：Phantom Reads 并发造成的

一个事务A在执行过程中读取到另一个事务B已提交的插入数据。
就是说在第一个事务开始时，读取到一批数据，但是此时另一个事务B又插入新数据并提交，此时第一个事务A又读取到这批数据但是发现多出了一条,貌似产生幻觉一样。这是并发造成的。

这块也明白了，这都是针对一个事务内的操作而言。

![phantom_read](https://hunzino1.github.io/assets/images/2019/interview/phantom_read.jpeg)

5 总结

上述四种，全是在并发情况下，一个事务内两次读取产生的现象。

其中1压根没事务，不聊；2是脏读，读取的是有问题的，不可取；3、4其实还好，都是正确的数据，只是3中某些情况可能会造成一些错误。

### 11 数据库锁

主要有：行锁，表锁，悲观锁，乐观锁

#### 为什么要锁？

就是为了防止并发操作的过程中，会发生多个事务对数据进行存取修改等操作，若不加以控制，就会出现脏读，不可重复读,幻读，死锁等情况，为了解决这个问题就有了锁机制，简单来说就是在一条sql语句执行时，会加上一个锁，在这个语句没有执行完之前，其他事务不能对数据进行操作。

#### 锁的实现原理？

MySQL以表级锁为主，对资源锁定的粒度很大，如果一个session对一个表加锁时间过长，会让其他session无法更新此表中的数据。虽然InnoDB引擎的表可以用行级锁，但这个行级锁的机制依赖于表的索引，如果表没有索引，或者sql语句没有使用索引，那么仍然使用表级锁。

Oracle使用行级锁，对资源锁定的粒度要小很多，只是锁定sql需要的资源，并且加锁是在数据库中的数据行上，不依赖与索引。所以Oracle对并发性的支持要好很多。

#### 各种锁

行锁：单独的一行记录加锁。

表锁：直接锁定整张表，在你锁定期间，其它进程无法对该表进行写操作。如果你是写锁，则其它进程则读也不允许。

悲观锁：即对所有操作持悲观态度，事务每次去操作数据的时候都假设有其他事务会修改需要访问的数据，所以在访问之前都要求上锁。

乐观锁：反之，只是在进行更新修改操作的时候判断一下在访问的期间有没有其他人修改数据

### 10 b树与b+树，聚类索引和非聚类索引的区别及内部实现

#### 1 b树与b+树

1 b树，如图

首先定义个M，相当于一个变形的M叉树吧，如图M=3

定义M之后，B树的约束有：

1. 关键字分布在整个树中；
2. 有序，就像有序二叉树一样；
3. 如图，一个node包含i个值以及i+1个指向孩子节点的指针，叶子节点也有，只是指向空；
4. 根节点至少有两个孩子节点，也就是至少有一个值
5. 其他节点至少有M/2个孩子节点，也就是至少有M/2 - 1个值；
6. 根节点和其他节点最多有M个孩子节点，也就是最多包含M-1个值。
7. 叶子节点都在同一层

![b_tree](https://hunzino1.github.io/assets/images/2019/interview/b_tree.JPG)

2 b+树

b树的变形，如图，定义基本相同：

说不同点：

1. b树节点关键字数比指向孩子节点的指针少1，而B+树是相等的，即一个关键字对应一个指针；
2. b书孩子节点和父节点是开区间，B+树是闭区间
3. 所有的关键字都在叶子节点上（为什么是闭区间的原因）
4. 为所有的叶子节点增加了一个链指针。

![b_plus_tree](https://hunzino1.github.io/assets/images/2019/interview/b+_tree.JPG)

B+的特性：

       1.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；

       2.更适合文件索引系统；


#### 2 聚类索引和非聚类索引的区别及内部实现

mysql中普遍使用B+Tree做索引，但在实现上又根据聚簇索引和非聚簇索引而不同。

1 聚类索引



2 非聚类索引

![index](https://hunzino1.github.io/assets/images/2019/interview/index.png)

### 11 一个mysql表如何建立索引

### 21 mysql索引，b树和b+树的区别

3 redis
---------------------

### 12 redis几个数据结构的内部实现原理

### 17 redis持久化

### 22 zset底层实现

### 23 跳跃表

### 24 redis集群


4 linux
-----------------------

### 16 epoll

### 18 软中断 硬中断的区别

### 19 top

### 20 监控机器指标的命令

### 25 tcp与udp

### 26 进程线程协程
