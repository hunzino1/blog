---
layout:     post
title:      内存系统2 - epoll
category: stack
tags: [stack]
excerpt: 一个人有多努力，就会有多幸运。
---

内存系统2 - epoll
=======================================

内存系统，印象中已经看过不止一次，学习epoll时看过，页缓存时看过，为什么一遍一遍的浪费精力，其实就是没有静下心来，

踏踏实实的将内存机制精通。

精通一个领域，既能避免重复的无意义时间浪费，又能成为自己的一个闪光点，win-win的举动。

通过本系列博客，我将会对内存系统进行系统的学习，过时的一些方案浅尝辄止，主要是对目前正在使用的内存机制进行总结。

当然，更多精彩可以见《鸟哥私房菜》，更加系统的学习。

-------------------------------------

1 大佬博客
------------------------------------

[基本内存管理](https://www.cnblogs.com/edisonchou/p/5090315.html)

[分页内存管理](https://www.cnblogs.com/edisonchou/p/5094066.html)

[段式内存管理](https://www.cnblogs.com/edisonchou/p/5115242.html)

以上上博客园一大神博客，仔细研读之后，认为对内存机制的阐述比较清晰全面，所以感觉不必浪费时间再去总结一把了。

入门已经够用了，如果想要深入了解，则需要研读《鸟哥》等大佬数据，去专门学习了。

在此只是对自己研读收获做一总结。

2 博客总结
--------------------------------------

### 2.1 博客脉络

如上，三篇博客按照 基本内存管理、分页内存管理、段式内存管理 三段式对计算机内存机制进行梳理，

从问题到解决方案展开探讨，以下只是自己对博客的总结以及自己的一些理解。

#### 2.1.1 基本内存管理

1 **操作系统(OS)的两个重要角色：CPU 和 内存**

```html
    OS内存管理的目的：
      1、地址保护：一个程序不能访问另一个程序地址空间。
　　  2、地址独立：程序发出的地址应该与物理主存地址无关。

    虚拟内存： 内存 + 硬盘的假设内存
      所以实际使用中，需要将硬盘中的数据交换到内存中，OS才能真正处理，此过程叫内存交换；
      内存交换过于频繁，OS处理速度就会下降甚至卡顿、停止响应，这种现象称为抖动（Thrushing）；
```

2 **基本内存管理**

```html'
    1 单道编程的内存管理
      整个内存里面只有两个程序：一个是用户程序，另一个是操作系统。
      静态地址翻译: 将用户程序总是加载到同一个内存起始地址，那么在程序运行之前就计算出所有的物理地址。

    2 多道编程的内存管理
      因为有多个用户程序，所以只能在程序加载完毕之后才能计算物理地址，也就是在程序运行时进行地址翻译，这种翻译称为动态地址翻译。
      需要使用地址翻译器(MMU)将虚拟地址匹配到物理内存地址。
```

3 **多道编程内存管理策略**

这部分可以看博客，分 固定分区 和 非固定分区两种。

重点是非固定分区，这是页式内存管理的基础实现，但是存在**空间浪费(碎片化) 和 程序大小受限**

**而页式内存管理就是解决了上述问题的一种非固定分区策略。**

4 **闲置空间管理**

闲置空间管理分 位图表示法 和 链表表示法 两种，很好理解。

#### 2.1.2 分页内存管理

1 **虚拟地址的构成与地址翻译**

虚拟地址的组成： 页面号 和 页内偏移量

页面号是用来定位物理内存页面(映射), 页内偏移量 是确定页中的数据起始位置。

下图很形象：

![address_map](https://hunzino1.github.io/assets/images/2019/os/address_map.jpg)
